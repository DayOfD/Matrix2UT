       |module matrix2ut;
       |
       |import std.algorithm: map, until;
       |import std.array:     Appender, array, empty, join;
       |import std.conv:      to;
       |import std.string:    format;
       |import std.range:     drop, sequence, take, walkLength;
       |
       |private:
       |
       |enum naturals = sequence!"a[0]+n"(1);
       |static assert(naturals[0] == 1);
       |
       |/**
       | * Parse header
       | * Returns: hashtable which has kinds of headers
       | *          and their indices
       | */
       |auto parse(in string[] header) pure @safe nothrow
       |{
      3|    size_t[][string] ret;
      3|    enum headerList = [
       |        "func_name", "temp_in", "in", "in_exp",
       |        "return", "out_exp", "result",
       |        ];
      3|    auto idx = naturals.map!"a-1";
      3|    auto hd = header[];
     72|    foreach(h; headerList)
       |    {
     21|        immutable len = hd.until!"a != b"(h).walkLength;
     21|        ret[h] = idx.take(len).array;
     21|        idx = idx.drop(len);
     21|        hd = hd.drop(len);
       |    }
      3|    assert(hd.empty);
      3|    return ret;
       |}
       |
       |///
       |pure @safe nothrow unittest
       |{
      1|    enum header = [
       |        "func_name",
       |        "temp_in", "temp_in",
       |        "in",
       |        "in_exp", "in_exp", "in_exp",
       |        "return",
       |        "out_exp", "out_exp",
       |        "result"];
      1|    enum ret = header.parse();
      1|    assert(ret["func_name"] == [0]);
      1|    assert(ret["temp_in"]   == [1, 2]);
      1|    assert(ret["in"]        == [3]);
      1|    assert(ret["in_exp"]    == [4, 5, 6]);
      1|    assert(ret["return"]    == [7]);
      1|    assert(ret["out_exp"]   == [8, 9]);
      1|    assert(ret["result"]    == [10]);
       |}
       |
       |pure @safe nothrow unittest
       |{
      1|    enum header = ["func_name", "in", "return"];
      1|    enum ret = header.parse();
      1|    assert(ret["func_name"] == [0]);
      1|    assert(ret["in"]        == [1]);
      1|    assert(ret["return"]    == [2]);
       |}
       |
       |string generateUnittest(in string[][] matrix) pure @safe
       |in
       |{
      3|    assert(matrix.length >= 2);
       |}
       |body
       |{
      3|    Appender!(string[]) utLines;
       |
      3|    utLines.put(q{import std.array,std.algorithm;});
      3|    utLines.put(q{Appender!(string[]) results;});
       |
      3|    const string[] header = matrix[0];
      3|    const string[] exps   = matrix[1]; 
       |
      3|    size_t[][string] headerParsed = header.parse();
      3|    size_t[] tempInIndices = headerParsed["temp_in"];
      3|    size_t[] inIndices     = headerParsed["in"];
      3|    size_t[] inExpIndices  = headerParsed["in_exp"];
      3|    size_t   returnIndex   = headerParsed["return"][0];
      3|    size_t[] outExpIndices = headerParsed["out_exp"];
       |
     33|    foreach (lineIndex, line; matrix[2..$])
       |    {
      6|        string funcName = line[0];
      6|        string lineIndexStr = (lineIndex + 2).to!string();
       |
     24|        foreach(inExpIndex; inExpIndices)
       |        {
      2|            utLines.put(exps[inExpIndex] ~ "=" ~ line[inExpIndex] ~ ";");
       |        }
       |
      6|        Appender!(string[]) tempArgs;
       |
     30|        foreach(tempInIndex; tempInIndices)
       |        {
      4|            tempArgs.put(line[tempInIndex]);
       |        }
       |
      6|        Appender!(string[]) funcArgs;
       |
     42|        foreach(inIndex; inIndices)
       |        {
      8|            funcArgs.put(line[inIndex]);
       |        }
       |
      6|        if (tempArgs.data.length)
       |        {
      2|            utLines.put(format("results.put(utAssert(`%s`,%s!(%s)(%s),%s));", funcName,
       |                                                                              funcName,
       |                                                                              tempArgs.data.join(","),
       |                                                                              funcArgs.data.join(","),
       |                                                                              line[returnIndex]));
       |        }
       |        else
       |        {
      4|            utLines.put(format("results.put(utAssert(`%s`,%s(%s),%s));", funcName,
       |                                                                         funcName,
       |                                                                         funcArgs.data.join(","),
       |                                                                         line[returnIndex]));
       |        }
       |
     24|        foreach(outExpIndex; outExpIndices)
       |        {
      2|            utLines.put("results.put(utAssert(`" ~ exps[outExpIndex] ~ "`," ~ exps[outExpIndex] ~ "," ~ line[outExpIndex] ~ "));");
       |        }
       |
      6|        utLines.put("reports[" ~ lineIndexStr ~ "][$-1]=results.data.filter!(str=>str.length)().join(\"\\n\");");
       |
      6|        utLines.put("if(reports[" ~ lineIndexStr ~ "][$-1].empty)reports[" ~ lineIndexStr ~ "][$-1]=\"OK\";");
       |
      6|        utLines.put("results.shrinkTo(0);");
       |    }
       |
      3|    return utLines.data.join();
       |}
       |
       |pure @safe unittest
       |{
      1|    assert(generateUnittest([["func_name", "in", "return", "result"],
       |                             ["",          "",   "",       ""],
       |                             ["hoge",      "1",  "2",      ""],
       |                             ["piyo",      "3",  "4",      ""]])
       |
       |                            ==
       |
       |                            "import std.array,std.algorithm;"
       |                            "Appender!(string[]) results;"
       |
       |                            "results.put(utAssert(`hoge`,hoge(1),2));"
       |                            "reports[2][$-1]=results.data.filter!(str=>str.length)().join(\"\\n\");"
       |                            "if(reports[2][$-1].empty)reports[2][$-1]=\"OK\";"
       |                            "results.shrinkTo(0);"
       |
       |                            "results.put(utAssert(`piyo`,piyo(3),4));"
       |                            "reports[3][$-1]=results.data.filter!(str=>str.length)().join(\"\\n\");"
       |                            "if(reports[3][$-1].empty)reports[3][$-1]=\"OK\";"
       |                            "results.shrinkTo(0);");
       |
      1|    assert(generateUnittest([["func_name", "temp_in", "temp_in", "in", "in", "return", "result"],
       |                             ["",          "",        "",        "",   "",   "",       ""],
       |                             ["hoge",      "int",     "long",    "1",  "2",  "3",      ""],
       |                             ["piyo",      "string",  "int[]",   "4",  "5",  "6",      ""]])
       |
       |                            ==
       |
       |                            "import std.array,std.algorithm;"
       |                            "Appender!(string[]) results;"
       |
       |                            "results.put(utAssert(`hoge`,hoge!(int,long)(1,2),3));"
       |                            "reports[2][$-1]=results.data.filter!(str=>str.length)().join(\"\\n\");"
       |                            "if(reports[2][$-1].empty)reports[2][$-1]=\"OK\";"
       |                            "results.shrinkTo(0);"
       |
       |                            "results.put(utAssert(`piyo`,piyo!(string,int[])(4,5),6));"
       |                            "reports[3][$-1]=results.data.filter!(str=>str.length)().join(\"\\n\");"
       |                            "if(reports[3][$-1].empty)reports[3][$-1]=\"OK\";"
       |                            "results.shrinkTo(0);");
       |
      1|    assert(generateUnittest([["func_name", "in", "in_exp", "return", "out_exp", "result"],
       |                             ["",          "",   "a",      "",       "b",       ""],
       |                             ["hoge",      "2",  "1",      "3",      "4",       ""],
       |                             ["piyo",      "6",  "5",      "7",      "8",       ""]])
       |
       |                            ==
       |
       |                            "import std.array,std.algorithm;"
       |                            "Appender!(string[]) results;"
       |
       |                            "a=1;"
       |                            "results.put(utAssert(`hoge`,hoge(2),3));"
       |                            "results.put(utAssert(`b`,b,4));"
       |                            "reports[2][$-1]=results.data.filter!(str=>str.length)().join(\"\\n\");"
       |                            "if(reports[2][$-1].empty)reports[2][$-1]=\"OK\";"
       |                            "results.shrinkTo(0);"
       |
       |                            "a=5;"
       |                            "results.put(utAssert(`piyo`,piyo(6),7));"
       |                            "results.put(utAssert(`b`,b,8));"
       |                            "reports[3][$-1]=results.data.filter!(str=>str.length)().join(\"\\n\");"
       |                            "if(reports[3][$-1].empty)reports[3][$-1]=\"OK\";"
       |                            "results.shrinkTo(0);");
       |}
       |
       |
       |/*******************************************************************************
       | * Read to convert csv to strings of 2D array.
       | */
       |string[][] to2DArray(string csvdata)
       |{
       |        import std.array, std.csv;
      1|        auto app = appender!(string[][])();
     11|        foreach (data; csvReader!string(csvdata))
       |        {
      3|                app.put(array(data).dup);
       |        }
      1|        return app.data;
       |}
       |
       |unittest
       |{
      1|        enum csvdata = "a,b,c\nd,e,f\ng,h,i";
       |        static assert(csvdata.to2DArray() == [["a", "b", "c"], ["d", "e", "f"], ["g", "h", "i"]]);
      1|        assert(csvdata.to2DArray() == [["a", "b", "c"], ["d", "e", "f"], ["g", "h", "i"]]);
       |}
       |
       |
       |
       |/*******************************************************************************
       | * Write csv from strings of 2D array.
       | */
       |string toCsvData(in string[][] strarys) pure
       |{
       |        import std.array, std.algorithm, std.conv;
      1|        auto app = appender!(string[][])();
      1|        auto appCells = appender!(string[])();
     12|        foreach (cols; strarys)
       |        {
     36|                foreach (cell; cols)
       |                {
      9|                        appCells.put(text(`"`, cell.replace(`"`, `""`), `"`));
       |                }
      3|                app.put(appCells.data.dup);
      3|                appCells.shrinkTo(0);
       |        }
      1|        return app.data.map!`a.join(",")`.join("\n");
       |}
       |
       |pure unittest
       |{
      1|        enum strarysdata = "a,b,c\nd,e,f\ng,h,i".to2DArray();
       |        static assert(strarysdata.toCsvData() == `"a","b","c"`"\n"`"d","e","f"`"\n"`"g","h","i"`);
      1|        assert(strarysdata.toCsvData() == `"a","b","c"`"\n"`"d","e","f"`"\n"`"g","h","i"`);
       |}
       |
       |
       |public:
       |
       |string utAssert(T)(string name, T right, T left)
       |{
       |        return null;
       |}
       |
       |string matrix2ut(string csvdata)
       |{
0000000|        return null;
       |}
matrix2ut.d is 98% covered
